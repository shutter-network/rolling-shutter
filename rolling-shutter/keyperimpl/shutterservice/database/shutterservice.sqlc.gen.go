// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: shutterservice.sql

package database

import (
	"context"

	"github.com/jackc/pgconn"
)

const deleteEventTriggerRegisteredEventsFromBlockNumber = `-- name: DeleteEventTriggerRegisteredEventsFromBlockNumber :exec
DELETE FROM event_trigger_registered_event WHERE block_number >= $1
`

func (q *Queries) DeleteEventTriggerRegisteredEventsFromBlockNumber(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, deleteEventTriggerRegisteredEventsFromBlockNumber, blockNumber)
	return err
}

const deleteFiredTriggersFromBlockNumber = `-- name: DeleteFiredTriggersFromBlockNumber :exec
DELETE FROM fired_triggers WHERE block_number >= $1
`

func (q *Queries) DeleteFiredTriggersFromBlockNumber(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, deleteFiredTriggersFromBlockNumber, blockNumber)
	return err
}

const deleteIdentityRegisteredEventsFromBlockNumber = `-- name: DeleteIdentityRegisteredEventsFromBlockNumber :exec
DELETE FROM identity_registered_event WHERE block_number >= $1
`

func (q *Queries) DeleteIdentityRegisteredEventsFromBlockNumber(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, deleteIdentityRegisteredEventsFromBlockNumber, blockNumber)
	return err
}

const getActiveEventTriggerRegisteredEvents = `-- name: GetActiveEventTriggerRegisteredEvents :many
SELECT block_number, block_hash, tx_index, log_index, eon, identity_prefix, sender, definition, ttl, decrypted, identity FROM event_trigger_registered_event e
WHERE e.block_number + ttl >= $1 -- TTL not expired at given block
AND e.decrypted = false  -- not decrypted yet
AND NOT EXISTS (  -- not fired yet
    SELECT 1 FROM fired_triggers t
    WHERE t.identity_prefix = e.identity_prefix
    AND t.sender = e.sender
)
`

func (q *Queries) GetActiveEventTriggerRegisteredEvents(ctx context.Context, blockNumber int64) ([]EventTriggerRegisteredEvent, error) {
	rows, err := q.db.Query(ctx, getActiveEventTriggerRegisteredEvents, blockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventTriggerRegisteredEvent
	for rows.Next() {
		var i EventTriggerRegisteredEvent
		if err := rows.Scan(
			&i.BlockNumber,
			&i.BlockHash,
			&i.TxIndex,
			&i.LogIndex,
			&i.Eon,
			&i.IdentityPrefix,
			&i.Sender,
			&i.Definition,
			&i.Ttl,
			&i.Decrypted,
			&i.Identity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentDecryptionTrigger = `-- name: GetCurrentDecryptionTrigger :one
SELECT eon, triggered_block_number, identities_hash FROM current_decryption_trigger
WHERE eon = $1 ORDER BY triggered_block_number DESC LIMIT 1
`

func (q *Queries) GetCurrentDecryptionTrigger(ctx context.Context, eon int64) (CurrentDecryptionTrigger, error) {
	row := q.db.QueryRow(ctx, getCurrentDecryptionTrigger, eon)
	var i CurrentDecryptionTrigger
	err := row.Scan(&i.Eon, &i.TriggeredBlockNumber, &i.IdentitiesHash)
	return i, err
}

const getDecryptionSignatures = `-- name: GetDecryptionSignatures :many
SELECT eon, keyper_index, identities_hash, signature FROM decryption_signatures
WHERE eon = $1 AND identities_hash = $2
ORDER BY keyper_index ASC
LIMIT $3
`

type GetDecryptionSignaturesParams struct {
	Eon            int64
	IdentitiesHash []byte
	Limit          int32
}

func (q *Queries) GetDecryptionSignatures(ctx context.Context, arg GetDecryptionSignaturesParams) ([]DecryptionSignature, error) {
	rows, err := q.db.Query(ctx, getDecryptionSignatures, arg.Eon, arg.IdentitiesHash, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DecryptionSignature
	for rows.Next() {
		var i DecryptionSignature
		if err := rows.Scan(
			&i.Eon,
			&i.KeyperIndex,
			&i.IdentitiesHash,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentityRegisteredEventsSyncedUntil = `-- name: GetIdentityRegisteredEventsSyncedUntil :one
SELECT enforce_one_row, block_hash, block_number FROM identity_registered_events_synced_until LIMIT 1
`

func (q *Queries) GetIdentityRegisteredEventsSyncedUntil(ctx context.Context) (IdentityRegisteredEventsSyncedUntil, error) {
	row := q.db.QueryRow(ctx, getIdentityRegisteredEventsSyncedUntil)
	var i IdentityRegisteredEventsSyncedUntil
	err := row.Scan(&i.EnforceOneRow, &i.BlockHash, &i.BlockNumber)
	return i, err
}

const getMultiEventSyncStatus = `-- name: GetMultiEventSyncStatus :one
SELECT enforce_one_row, block_number, block_hash FROM multi_event_sync_status LIMIT 1
`

func (q *Queries) GetMultiEventSyncStatus(ctx context.Context) (MultiEventSyncStatus, error) {
	row := q.db.QueryRow(ctx, getMultiEventSyncStatus)
	var i MultiEventSyncStatus
	err := row.Scan(&i.EnforceOneRow, &i.BlockNumber, &i.BlockHash)
	return i, err
}

const getNotDecryptedIdentityRegisteredEvents = `-- name: GetNotDecryptedIdentityRegisteredEvents :many
SELECT block_number, block_hash, tx_index, log_index, eon, identity_prefix, sender, timestamp, decrypted, identity FROM identity_registered_event
WHERE timestamp >= $1 AND timestamp <= $2 AND decrypted = false
ORDER BY timestamp ASC
`

type GetNotDecryptedIdentityRegisteredEventsParams struct {
	Timestamp   int64
	Timestamp_2 int64
}

func (q *Queries) GetNotDecryptedIdentityRegisteredEvents(ctx context.Context, arg GetNotDecryptedIdentityRegisteredEventsParams) ([]IdentityRegisteredEvent, error) {
	rows, err := q.db.Query(ctx, getNotDecryptedIdentityRegisteredEvents, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdentityRegisteredEvent
	for rows.Next() {
		var i IdentityRegisteredEvent
		if err := rows.Scan(
			&i.BlockNumber,
			&i.BlockHash,
			&i.TxIndex,
			&i.LogIndex,
			&i.Eon,
			&i.IdentityPrefix,
			&i.Sender,
			&i.Timestamp,
			&i.Decrypted,
			&i.Identity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUndecryptedFiredTriggers = `-- name: GetUndecryptedFiredTriggers :many
SELECT
   f.identity_prefix,
   f.sender,
   f.block_number,
   f.block_hash,
   f.tx_index,
   f.log_index,
   e.eon AS eon,
   e.ttl AS ttl,
   e.identity AS identity,
   e.decrypted AS decrypted
FROM fired_triggers f
INNER JOIN event_trigger_registered_event e ON f.identity_prefix = e.identity_prefix AND f.sender = e.sender
WHERE NOT EXISTS (  -- not decrypted yet
    SELECT 1 FROM event_trigger_registered_event e
    WHERE e.identity_prefix = f.identity_prefix
    AND e.sender = f.sender
    AND e.decrypted = true
)
`

type GetUndecryptedFiredTriggersRow struct {
	IdentityPrefix []byte
	Sender         string
	BlockNumber    int64
	BlockHash      []byte
	TxIndex        int64
	LogIndex       int64
	Eon            int64
	Ttl            int64
	Identity       []byte
	Decrypted      bool
}

func (q *Queries) GetUndecryptedFiredTriggers(ctx context.Context) ([]GetUndecryptedFiredTriggersRow, error) {
	rows, err := q.db.Query(ctx, getUndecryptedFiredTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUndecryptedFiredTriggersRow
	for rows.Next() {
		var i GetUndecryptedFiredTriggersRow
		if err := rows.Scan(
			&i.IdentityPrefix,
			&i.Sender,
			&i.BlockNumber,
			&i.BlockHash,
			&i.TxIndex,
			&i.LogIndex,
			&i.Eon,
			&i.Ttl,
			&i.Identity,
			&i.Decrypted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDecryptionSignature = `-- name: InsertDecryptionSignature :exec
INSERT INTO decryption_signatures (eon, keyper_index, identities_hash, signature)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
`

type InsertDecryptionSignatureParams struct {
	Eon            int64
	KeyperIndex    int64
	IdentitiesHash []byte
	Signature      []byte
}

func (q *Queries) InsertDecryptionSignature(ctx context.Context, arg InsertDecryptionSignatureParams) error {
	_, err := q.db.Exec(ctx, insertDecryptionSignature,
		arg.Eon,
		arg.KeyperIndex,
		arg.IdentitiesHash,
		arg.Signature,
	)
	return err
}

const insertEventTriggerRegisteredEvent = `-- name: InsertEventTriggerRegisteredEvent :execresult
INSERT INTO event_trigger_registered_event (
    block_number,
    block_hash,
    tx_index,
    log_index,
    eon,
    identity_prefix,
    sender,
    definition,
    ttl,
    identity
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (identity_prefix, sender) DO UPDATE SET
block_number = $1,
block_hash = $2,
tx_index = $3,
log_index = $4,
sender = $7,
definition = $8,
ttl = $9,
identity = $10
`

type InsertEventTriggerRegisteredEventParams struct {
	BlockNumber    int64
	BlockHash      []byte
	TxIndex        int64
	LogIndex       int64
	Eon            int64
	IdentityPrefix []byte
	Sender         string
	Definition     []byte
	Ttl            int64
	Identity       []byte
}

func (q *Queries) InsertEventTriggerRegisteredEvent(ctx context.Context, arg InsertEventTriggerRegisteredEventParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertEventTriggerRegisteredEvent,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.LogIndex,
		arg.Eon,
		arg.IdentityPrefix,
		arg.Sender,
		arg.Definition,
		arg.Ttl,
		arg.Identity,
	)
}

const insertFiredTrigger = `-- name: InsertFiredTrigger :exec
INSERT INTO fired_triggers (identity_prefix, sender, block_number, block_hash, tx_index, log_index)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (identity_prefix, sender) DO NOTHING
`

type InsertFiredTriggerParams struct {
	IdentityPrefix []byte
	Sender         string
	BlockNumber    int64
	BlockHash      []byte
	TxIndex        int64
	LogIndex       int64
}

func (q *Queries) InsertFiredTrigger(ctx context.Context, arg InsertFiredTriggerParams) error {
	_, err := q.db.Exec(ctx, insertFiredTrigger,
		arg.IdentityPrefix,
		arg.Sender,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.LogIndex,
	)
	return err
}

const insertIdentityRegisteredEvent = `-- name: InsertIdentityRegisteredEvent :execresult
INSERT INTO identity_registered_event (
    block_number,
    block_hash,
    tx_index,
    log_index,
    eon,
    identity_prefix,
    sender,
    timestamp,
    identity
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (identity_prefix, sender) DO UPDATE SET
block_number = $1,
block_hash = $2,
tx_index = $3,
log_index = $4,
sender = $7,
timestamp = $8,
identity = $9
`

type InsertIdentityRegisteredEventParams struct {
	BlockNumber    int64
	BlockHash      []byte
	TxIndex        int64
	LogIndex       int64
	Eon            int64
	IdentityPrefix []byte
	Sender         string
	Timestamp      int64
	Identity       []byte
}

func (q *Queries) InsertIdentityRegisteredEvent(ctx context.Context, arg InsertIdentityRegisteredEventParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertIdentityRegisteredEvent,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.LogIndex,
		arg.Eon,
		arg.IdentityPrefix,
		arg.Sender,
		arg.Timestamp,
		arg.Identity,
	)
}

const setCurrentDecryptionTrigger = `-- name: SetCurrentDecryptionTrigger :exec
INSERT INTO current_decryption_trigger (eon, triggered_block_number, identities_hash)
VALUES ($1, $2, $3)
ON CONFLICT (eon, triggered_block_number) DO UPDATE
SET triggered_block_number = $2, identities_hash = $3
`

type SetCurrentDecryptionTriggerParams struct {
	Eon                  int64
	TriggeredBlockNumber int64
	IdentitiesHash       []byte
}

func (q *Queries) SetCurrentDecryptionTrigger(ctx context.Context, arg SetCurrentDecryptionTriggerParams) error {
	_, err := q.db.Exec(ctx, setCurrentDecryptionTrigger, arg.Eon, arg.TriggeredBlockNumber, arg.IdentitiesHash)
	return err
}

const setIdentityRegisteredEventSyncedUntil = `-- name: SetIdentityRegisteredEventSyncedUntil :exec
INSERT INTO identity_registered_events_synced_until (block_hash, block_number) VALUES ($1, $2)
ON CONFLICT (enforce_one_row) DO UPDATE
SET block_hash = $1, block_number = $2
`

type SetIdentityRegisteredEventSyncedUntilParams struct {
	BlockHash   []byte
	BlockNumber int64
}

func (q *Queries) SetIdentityRegisteredEventSyncedUntil(ctx context.Context, arg SetIdentityRegisteredEventSyncedUntilParams) error {
	_, err := q.db.Exec(ctx, setIdentityRegisteredEventSyncedUntil, arg.BlockHash, arg.BlockNumber)
	return err
}

const setMultiEventSyncStatus = `-- name: SetMultiEventSyncStatus :exec
INSERT INTO multi_event_sync_status (block_number, block_hash) VALUES ($1, $2)
ON CONFLICT (enforce_one_row) DO UPDATE
SET block_number = $1, block_hash = $2
`

type SetMultiEventSyncStatusParams struct {
	BlockNumber int64
	BlockHash   []byte
}

func (q *Queries) SetMultiEventSyncStatus(ctx context.Context, arg SetMultiEventSyncStatusParams) error {
	_, err := q.db.Exec(ctx, setMultiEventSyncStatus, arg.BlockNumber, arg.BlockHash)
	return err
}

const updateEventBasedDecryptedFlags = `-- name: UpdateEventBasedDecryptedFlags :exec
UPDATE event_trigger_registered_event
SET decrypted = TRUE
WHERE (eon, identity) IN (
    SELECT UNNEST($1::bigint[]), UNNEST($2::bytea[])
)
`

type UpdateEventBasedDecryptedFlagsParams struct {
	Eons       []int64
	Identities [][]byte
}

func (q *Queries) UpdateEventBasedDecryptedFlags(ctx context.Context, arg UpdateEventBasedDecryptedFlagsParams) error {
	_, err := q.db.Exec(ctx, updateEventBasedDecryptedFlags, arg.Eons, arg.Identities)
	return err
}

const updateTimeBasedDecryptedFlags = `-- name: UpdateTimeBasedDecryptedFlags :exec
UPDATE identity_registered_event
SET decrypted = TRUE
WHERE (eon, identity) IN (
    SELECT UNNEST($1::bigint[]), UNNEST($2::bytea[])
)
`

type UpdateTimeBasedDecryptedFlagsParams struct {
	Eons       []int64
	Identities [][]byte
}

func (q *Queries) UpdateTimeBasedDecryptedFlags(ctx context.Context, arg UpdateTimeBasedDecryptedFlagsParams) error {
	_, err := q.db.Exec(ctx, updateTimeBasedDecryptedFlags, arg.Eons, arg.Identities)
	return err
}
