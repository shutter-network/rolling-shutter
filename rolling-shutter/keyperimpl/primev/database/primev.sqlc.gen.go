// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: primev.sql

package database

import (
	"context"

	"github.com/jackc/pgconn"
)

const deleteProviderRegistryEventsFromBlockNumber = `-- name: DeleteProviderRegistryEventsFromBlockNumber :exec
DELETE FROM provider_registry_events WHERE block_number >= $1
`

func (q *Queries) DeleteProviderRegistryEventsFromBlockNumber(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, deleteProviderRegistryEventsFromBlockNumber, blockNumber)
	return err
}

const getCommitmentByTxHash = `-- name: GetCommitmentByTxHash :many
SELECT
    c.tx_hashes,
    c.provider_address,
    c.commitment_signature,
    c.commitment_digest,
    c.block_number,
    c.received_bid_digest,
    c.received_bid_signature,
    c.bidder_node_address
FROM commitment c
WHERE $1 = ANY(c.tx_hashes)
`

func (q *Queries) GetCommitmentByTxHash(ctx context.Context, txHashes []string) ([]Commitment, error) {
	rows, err := q.db.Query(ctx, getCommitmentByTxHash, txHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Commitment
	for rows.Next() {
		var i Commitment
		if err := rows.Scan(
			&i.TxHashes,
			&i.ProviderAddress,
			&i.CommitmentSignature,
			&i.CommitmentDigest,
			&i.BlockNumber,
			&i.ReceivedBidDigest,
			&i.ReceivedBidSignature,
			&i.BidderNodeAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviderRegistryEventsSyncedUntil = `-- name: GetProviderRegistryEventsSyncedUntil :one
SELECT enforce_one_row, block_hash, block_number FROM provider_registry_events_synced_until LIMIT 1
`

func (q *Queries) GetProviderRegistryEventsSyncedUntil(ctx context.Context) (ProviderRegistryEventsSyncedUntil, error) {
	row := q.db.QueryRow(ctx, getProviderRegistryEventsSyncedUntil)
	var i ProviderRegistryEventsSyncedUntil
	err := row.Scan(&i.EnforceOneRow, &i.BlockHash, &i.BlockNumber)
	return i, err
}

const insertMultipleTransactionsAndUpsertCommitment = `-- name: InsertMultipleTransactionsAndUpsertCommitment :exec
WITH inserted_transactions AS (
    INSERT INTO committed_transactions (eon, identity_preimage, identity_prefix, block_number, tx_hash, commitment_digest, provider_address)
    SELECT
        unnest($1::bigint[]) as eon,
        unnest($2::text[]) as identity_preimage,
        unnest($3::text[]) as identity_prefix,
        unnest($4::bigint[]) as block_number,
        unnest($5::text[]) as tx_hash,
        $6,
        $7
    ON CONFLICT (eon, identity_preimage, tx_hash, block_number)
    DO NOTHING
    RETURNING tx_hash as hashes
),
upserted_commitment AS (
    INSERT INTO commitment (tx_hashes, provider_address, commitment_signature, commitment_digest, block_number, received_bid_digest, received_bid_signature, bidder_node_address)
    SELECT
        ARRAY_AGG(hashes),
        $7,
        $8,
        $6,
        $9,
        $10,
        $11,
        $12
    FROM inserted_transactions
    ON CONFLICT (provider_address, commitment_digest)
    DO UPDATE SET
        tx_hashes = commitment.tx_hashes || EXCLUDED.tx_hashes,
        received_bid_digest = EXCLUDED.received_bid_digest,
        received_bid_signature = EXCLUDED.received_bid_signature,
        bidder_node_address = EXCLUDED.bidder_node_address
    RETURNING tx_hashes, provider_address
)
SELECT tx_hashes, provider_address FROM upserted_commitment
`

type InsertMultipleTransactionsAndUpsertCommitmentParams struct {
	Eons                 []int64
	IdentityPreimages    []string
	IdentityPrefixes     []string
	BlockNumbers         []int64
	TxHashes             []string
	CommitmentDigest     string
	ProviderAddress      string
	CommitmentSignature  string
	BlockNumber          int64
	ReceivedBidDigest    string
	ReceivedBidSignature string
	BidderNodeAddress    string
}

func (q *Queries) InsertMultipleTransactionsAndUpsertCommitment(ctx context.Context, arg InsertMultipleTransactionsAndUpsertCommitmentParams) error {
	_, err := q.db.Exec(ctx, insertMultipleTransactionsAndUpsertCommitment,
		arg.Eons,
		arg.IdentityPreimages,
		arg.IdentityPrefixes,
		arg.BlockNumbers,
		arg.TxHashes,
		arg.CommitmentDigest,
		arg.ProviderAddress,
		arg.CommitmentSignature,
		arg.BlockNumber,
		arg.ReceivedBidDigest,
		arg.ReceivedBidSignature,
		arg.BidderNodeAddress,
	)
	return err
}

const insertProviderRegistryEvent = `-- name: InsertProviderRegistryEvent :execresult
INSERT INTO provider_registry_events (block_number, block_hash, tx_index, log_index, provider_address, bls_keys)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (block_number, tx_index, log_index) DO UPDATE SET
block_number = $1,
block_hash = $2,
tx_index = $3,
log_index = $4,
bls_keys = $6
`

type InsertProviderRegistryEventParams struct {
	BlockNumber     int64
	BlockHash       []byte
	TxIndex         int64
	LogIndex        int64
	ProviderAddress string
	BlsKeys         [][]byte
}

func (q *Queries) InsertProviderRegistryEvent(ctx context.Context, arg InsertProviderRegistryEventParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertProviderRegistryEvent,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.LogIndex,
		arg.ProviderAddress,
		arg.BlsKeys,
	)
}

const setProviderRegistryEventsSyncedUntil = `-- name: SetProviderRegistryEventsSyncedUntil :exec
INSERT INTO provider_registry_events_synced_until (block_hash, block_number) VALUES ($1, $2)
ON CONFLICT (enforce_one_row) DO UPDATE
SET block_hash = $1, block_number = $2
`

type SetProviderRegistryEventsSyncedUntilParams struct {
	BlockHash   []byte
	BlockNumber int64
}

func (q *Queries) SetProviderRegistryEventsSyncedUntil(ctx context.Context, arg SetProviderRegistryEventsSyncedUntilParams) error {
	_, err := q.db.Exec(ctx, setProviderRegistryEventsSyncedUntil, arg.BlockHash, arg.BlockNumber)
	return err
}
