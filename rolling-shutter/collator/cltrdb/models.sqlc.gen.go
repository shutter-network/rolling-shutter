// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0

package cltrdb

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
)

type Txstatus string

const (
	TxstatusNew       Txstatus = "new"
	TxstatusRejected  Txstatus = "rejected"
	TxstatusCommitted Txstatus = "committed"
)

func (e *Txstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Txstatus(s)
	case string:
		*e = Txstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Txstatus: %T", src)
	}
	return nil
}

type NullTxstatus struct {
	Txstatus Txstatus
	Valid    bool // Valid is true if Txstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Txstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Txstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return ns.Txstatus, nil
}

type DecryptionKey struct {
	EpochID       []byte
	DecryptionKey []byte
}

type DecryptionTrigger struct {
	EpochID       []byte
	ID            int32
	BatchHash     []byte
	L1BlockNumber int64
	Sent          sql.NullTime
}

type EonPublicKeyCandidate struct {
	Hash                  []byte
	EonPublicKey          []byte
	ActivationBlockNumber int64
	KeyperConfigIndex     int64
	Eon                   int64
	Confirmed             bool
}

type EonPublicKeyVote struct {
	Hash              []byte
	Sender            string
	Signature         []byte
	Eon               int64
	KeyperConfigIndex int64
}

type MetaInf struct {
	Key   string
	Value string
}

type NextBatch struct {
	EnforceOneRow bool
	EpochID       []byte
	L1BlockNumber int64
}

type Transaction struct {
	TxHash  []byte
	ID      sql.NullInt32
	EpochID []byte
	TxBytes []byte
	Status  Txstatus
}
